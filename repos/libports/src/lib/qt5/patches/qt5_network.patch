qt5_network.patch

From: Christian Prochaska <christian.prochaska@genode-labs.com>
From: Alexy Gallardo Segura <alexy@uclv.cu>

From: Reinier Millo SÃ¡nchez <rmillo@uclv.cu>

---
 qtbase/include/QtNetwork/QtNetworkDepends               |  4 ++++
 qtbase/src/network/access/qhttpnetworkreply.cpp         |  8 ++++++++
 qtbase/src/network/access/qnetworkaccessfilebackend.cpp |  5 +++++
 qtbase/src/network/kernel/qhostinfo.cpp                 |  5 +++++
 qtbase/src/network/kernel/qhostinfo_unix.cpp            |  7 ++++++-
 qtbase/src/network/socket/qabstractsocket.cpp           |  2 +-
 qtbase/src/network/socket/qnativesocketengine_p.h       |  8 ++++----
 qtbase/src/network/socket/qnativesocketengine_unix.cpp  | 16 ++++++++++++++++
 qtbase/src/network/ssl/qsslconfiguration_p.h            |  9 +++++++++
 qtbase/src/network/ssl/qsslsocket_openssl.cpp           |  3 +++
 10 files changed, 61 insertions(+), 6 deletions(-)
 create mode 100644 qtbase/include/QtNetwork/QtNetworkDepends

diff --git a/qtbase/include/QtNetwork/QtNetworkDepends b/qtbase/include/QtNetwork/QtNetworkDepends
new file mode 100644
index 0000000..511727a
--- /dev/null
+++ b/qtbase/include/QtNetwork/QtNetworkDepends
@@ -0,0 +1,4 @@
+/* This file was generated by qmake with the info from <root>/src/network/network.pro. */
+#ifdef __cplusplus /* create empty PCH in C mode */
+#include <QtCore/QtCore>
+#endif
diff --git a/qtbase/src/network/access/qhttpnetworkreply.cpp b/qtbase/src/network/access/qhttpnetworkreply.cpp
index 2063ca6..57d1046 100644
--- a/qtbase/src/network/access/qhttpnetworkreply.cpp
+++ b/qtbase/src/network/access/qhttpnetworkreply.cpp
@@ -230,8 +230,16 @@ void QHttpNetworkReply::setReadBufferSize(qint64 size)
 
 bool QHttpNetworkReply::supportsUserProvidedDownloadBuffer()
 {
+#ifdef Q_OS_GENODE
+	/*
+	 * Without this change Arora shows garbage when loading, for example,
+	 * www.genode.org
+	 */
+	return false;
+#else
     Q_D(QHttpNetworkReply);
     return (!d->isChunked() && !d->autoDecompress && d->bodyLength > 0 && d->statusCode == 200);
+#endif
 }
 
 void QHttpNetworkReply::setUserProvidedDownloadBuffer(char* b)
diff --git a/qtbase/src/network/access/qnetworkaccessfilebackend.cpp b/qtbase/src/network/access/qnetworkaccessfilebackend.cpp
index bb97bae..38de88b 100644
--- a/qtbase/src/network/access/qnetworkaccessfilebackend.cpp
+++ b/qtbase/src/network/access/qnetworkaccessfilebackend.cpp
@@ -118,6 +118,7 @@ void QNetworkAccessFileBackend::open()
         url.setPath(QLatin1String("/"));
     setUrl(url);
 
+#ifndef Q_OS_GENODE
     QString fileName = url.toLocalFile();
     if (fileName.isEmpty()) {
         if (url.scheme() == QLatin1String("qrc")) {
@@ -131,6 +132,10 @@ void QNetworkAccessFileBackend::open()
                 fileName = url.toString(QUrl::RemoveAuthority | QUrl::RemoveFragment | QUrl::RemoveQuery);
         }
     }
+#else
+    QString fileName = QLatin1String(":") + url.path();
+#endif
+
     file.setFileName(fileName);
 
     if (operation() == QNetworkAccessManager::GetOperation) {
diff --git a/qtbase/src/network/kernel/qhostinfo.cpp b/qtbase/src/network/kernel/qhostinfo.cpp
index a2ac906..6bdd38b 100644
--- a/qtbase/src/network/kernel/qhostinfo.cpp
+++ b/qtbase/src/network/kernel/qhostinfo.cpp
@@ -500,7 +500,12 @@ QHostInfoLookupManager::QHostInfoLookupManager() : mutex(QMutex::Recursive), was
 {
     moveToThread(QCoreApplicationPrivate::mainThread());
     connect(QCoreApplication::instance(), SIGNAL(destroyed()), SLOT(waitForThreadPoolDone()), Qt::DirectConnection);
+#ifdef Q_OS_GENODE
+    /* 'getaddrinfo()' is currently not thread-safe on Genode */
+    threadPool.setMaxThreadCount(1);
+#else
     threadPool.setMaxThreadCount(20); // do up to 20 DNS lookups in parallel
+#endif
 }
 
 QHostInfoLookupManager::~QHostInfoLookupManager()
diff --git a/qtbase/src/network/kernel/qhostinfo_unix.cpp b/qtbase/src/network/kernel/qhostinfo_unix.cpp
index 90a6f76..42fbde5 100644
--- a/qtbase/src/network/kernel/qhostinfo_unix.cpp
+++ b/qtbase/src/network/kernel/qhostinfo_unix.cpp
@@ -147,6 +147,11 @@ QHostInfo QHostInfoAgent::fromName(const QString &hostName)
     QHostAddress address;
     if (address.setAddress(hostName)) {
         // Reverse lookup
+#ifdef Q_OS_GENODE
+    results.setError(QHostInfo::HostNotFound);
+    results.setErrorString(tr("Reverse lookup is not implemented because of missing support in lwip."));
+    return results;
+#else
 // Reverse lookups using getnameinfo are broken on darwin, use gethostbyaddr instead.
 #if !defined (QT_NO_GETADDRINFO) && !defined (Q_OS_DARWIN)
         sockaddr_in sa4;
@@ -177,7 +182,7 @@ QHostInfo QHostInfoAgent::fromName(const QString &hostName)
         if (ent)
             results.setHostName(QString::fromLatin1(ent->h_name));
 #endif
-
+#endif
         if (results.hostName().isEmpty())
             results.setHostName(address.toString());
         results.setAddresses(QList<QHostAddress>() << address);
diff --git a/qtbase/src/network/socket/qabstractsocket.cpp b/qtbase/src/network/socket/qabstractsocket.cpp
index f5dcdcb..04834cc 100644
--- a/qtbase/src/network/socket/qabstractsocket.cpp
+++ b/qtbase/src/network/socket/qabstractsocket.cpp
@@ -746,7 +746,7 @@ bool QAbstractSocketPrivate::canReadNotification()
         if (isBuffered)
             socketEngine->setReadNotificationEnabled(readBufferMaxSize == 0 || readBufferMaxSize > q->bytesAvailable());
         else if (socketType != QAbstractSocket::TcpSocket)
-            socketEngine->setReadNotificationEnabled(!socketEngine->hasPendingDatagrams());
+            socketEngine->setReadNotificationEnabled(true);
     }
 
     // reset the read socket notifier state if we reentered inside the
diff --git a/qtbase/src/network/socket/qnativesocketengine_p.h b/qtbase/src/network/socket/qnativesocketengine_p.h
index 24909bf..5d87891 100644
--- a/qtbase/src/network/socket/qnativesocketengine_p.h
+++ b/qtbase/src/network/socket/qnativesocketengine_p.h
@@ -134,11 +134,11 @@ public:
     qint64 write(const char *data, qint64 len) Q_DECL_OVERRIDE;
 
     qint64 readDatagram(char *data, qint64 maxlen, QHostAddress *addr = 0,
-                            quint16 *port = 0) Q_DECL_OVERRIDE;
+                            quint16 *port = 0) ;
     qint64 writeDatagram(const char *data, qint64 len, const QHostAddress &addr,
-                             quint16 port) Q_DECL_OVERRIDE;
-    bool hasPendingDatagrams() const Q_DECL_OVERRIDE;
-    qint64 pendingDatagramSize() const Q_DECL_OVERRIDE;
+                             quint16 port) ;
+    bool hasPendingDatagrams() const ;
+    qint64 pendingDatagramSize() const ;
 
     qint64 bytesToWrite() const Q_DECL_OVERRIDE;
 
diff --git a/qtbase/src/network/socket/qnativesocketengine_unix.cpp b/qtbase/src/network/socket/qnativesocketengine_unix.cpp
index 4648a3c..fb0ed69 100644
--- a/qtbase/src/network/socket/qnativesocketengine_unix.cpp
+++ b/qtbase/src/network/socket/qnativesocketengine_unix.cpp
@@ -395,6 +395,22 @@ bool QNativeSocketEnginePrivate::nativeConnect(const QHostAddress &addr, quint16
         case EISCONN:
             socketState = QAbstractSocket::ConnectedState;
             break;
+#ifdef Q_OS_GENODE
+        /* to have Arora get an error indication, socketState needs to change
+         * to "ConnectingState" before changing to "UnconnectedState" again
+         */
+        case ECONNABORTED:
+            if (socketState == QAbstractSocket::UnconnectedState) {
+                /* interpret ECONNABORTED as EINPROGRESS */
+                setError(QAbstractSocket::UnfinishedSocketOperationError, InvalidSocketErrorString);
+                socketState = QAbstractSocket::ConnectingState;
+            } else {
+                /* interpret ECONNABORTED as EHOSTUNREACH */
+                setError(QAbstractSocket::NetworkError, HostUnreachableErrorString);
+                socketState = QAbstractSocket::UnconnectedState;
+            }
+            break;
+#endif
         case ECONNREFUSED:
         case EINVAL:
             setError(QAbstractSocket::ConnectionRefusedError, ConnectionRefusedErrorString);
diff --git a/qtbase/src/network/ssl/qsslconfiguration_p.h b/qtbase/src/network/ssl/qsslconfiguration_p.h
index 3fd1252..56251ca 100644
--- a/qtbase/src/network/ssl/qsslconfiguration_p.h
+++ b/qtbase/src/network/ssl/qsslconfiguration_p.h
@@ -76,7 +76,16 @@ public:
     QSslConfigurationPrivate()
         : sessionProtocol(QSsl::UnknownProtocol),
           protocol(QSsl::SecureProtocols),
+#ifdef Q_OS_GENODE
+          /*
+           * With enabled peer verification, currently often a 'handshake error'
+           * occurs. This patch disables the peer verification until a fix for
+           * the handshake problem has been found.
+           */
+          peerVerifyMode(QSslSocket::VerifyNone),
+#else
           peerVerifyMode(QSslSocket::AutoVerifyPeer),
+#endif
           peerVerifyDepth(0),
           allowRootCertOnDemandLoading(true),
           peerSessionShared(false),
diff --git a/qtbase/src/network/ssl/qsslsocket_openssl.cpp b/qtbase/src/network/ssl/qsslsocket_openssl.cpp
index 049666b..4060f5e 100644
--- a/qtbase/src/network/ssl/qsslsocket_openssl.cpp
+++ b/qtbase/src/network/ssl/qsslsocket_openssl.cpp
@@ -482,7 +482,10 @@ bool QSslSocketPrivate::ensureLibraryLoaded()
         if (q_SSL_library_init() != 1)
             return false;
         q_SSL_load_error_strings();
+#ifndef Q_OS_GENODE
+        /* FIXME: currently, on Genode this function causes 'exit(1)' */
         q_OpenSSL_add_all_algorithms();
+#endif
 
 #if OPENSSL_VERSION_NUMBER >= 0x10001000L
         if (q_SSLeay() >= 0x10001000L)
